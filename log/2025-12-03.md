# 'The Many Meanings of Event-Driven Architecture • Martin Fowler • GOTO 2017' 발표 정리

## Event Notification

이 방식의 핵심 목표는 '의존성을 역전'을 통해 결합도를 낮추는 것.

e.g. '고객 관리 시스템 <-> 보험 시스템' 구조에서 고객이 주소를 변경했을 때, 보험 시스템의 보험료 재산정 필요.
- 전통적인 방식: 고객 관리 시스템이 보험 시스템의 재산정 API 직접 호출
- 이벤트 알림: 고객 관리 시스템은 주소 변경 이벤트 발행. 보험 시스템은 해당 이벤트 구독하여 재산정

> 시스템 간의 의존성 방향이 역전

### 이벤트 네이밍 관련

- Command: "이 고객의 보험료를 재산정하라"
- Event: "고객의 주소가 변경되었다"

기술적으로는 큐에 담긴 메시지로 동일할 수 있지만, 이름에 담긴 의도의 차이가 시스템의 통신 패턴을 이해하는 방식에 지대한 영향을 준다고 한다.

어떤 실질적인 영향이 있을까?

기본적으로 구현되는 로직의 위치가 다르다.

- Command: “주소 바뀌면 보험료 재산정 필요” 로직이 고객 관리 시스템에 있음
- Event: 그 로직이 보험 시스템에 있음 (도메인 응집도 증가)

따라서, 정책에 변경이 생기면 수정되는 위치도 달라진다.

### 장점

- **강력한 디커플링**: 시스템 간 직접적인 호출 관계 제거
- **유연성 및 확장성**: 기존 이벤트를 발행하는 시스템을 전혀 수정하지 않고도 새로운 비즈니스 요구사항에 대응하는 구독 시스템(소비자)을 쉽게 추가할 수 있음

### 단점

- **전체 시스템의 동작 흐름을 파악하기 어렵다**: 전체 흐름을 코드만 보고 직관적으로 파악하기 어려움

이 단점을 보완하는게 Observability로 알고 있는데, 분산 트레이싱을 통해 이벤트로 전파된 로직을 추적 가능하도록 만들 수 있다. (아마도)


## Event Carried State Transfer

> 이벤트 자체에 필요한 모든 데이터를 담아 전송

각 시스템이 독립적으로 작동할 수 있는 자율성(Autonomy)과 가용성(Availability)을 극대화하는 방법.

Event Notification 패턴과의 가장 큰 차이점은 '이벤트에 포함되는 데이터의 양'.

단순히 '주소가 변경되었다'고 알리는 대신, 이벤트에 '이전 주소'와 '새로운 주소' 등 관련된 상태 데이터를 모두 포함하여 전송한다.

### 장점

- **발행 시스템 부하 감소**: 구독 시스템이 발행 시스템을 다시 호출하는 원격 네트워크 통신이 사라짐 (구독 시스템이 여러개일 경우 더 심각해지는 부분)
- **가용성 향상**: 발행 시스템이 일시적으로 다운되거나 응답이 느려져도 구독 시스템에는 영향이 없음

### 단점

- **최종적 일관성(Eventual Consistency)**: 각 시스템이 데이터의 복제본을 유지하게 되어, 특정 시점에는 시스템 간 데이터가 일치하지 않는 상태가 발생 + 동기화 복잡성 증가

## Event Sourcing

> 현재 상태에 이르게 된 모든 변경 이벤트의 전체 로그(log)를 저장

애플리케이션의 현재 상태는 이벤트 로그를 처음부터 순서대로 재실행(replay)하여 계산된 결과가 된다.

"언제든지 애플리케이션의 현재 상태를 모두 지우고, 오직 이벤트 로그로부터만 상태를 자신 있게 재구축할 수 있어야 한다." 를 충족해야 됨.

영상에서 이벤트 소싱 시스템의 예시로 git과 회계 원장을 언급한다.

### 장점

- **감사 및 디버깅**
- **복잡한 비즈니스 로직 처리**

```
6개월 전 급여 계산에 오류가 있었음이 발견되었다고 가정해 봅시다.
이 오류는 급여뿐만 아니라 "병가 수당, 연금 혜택 등 모든 종류의 하위 시스템에 영향을 미쳤을 것"입니다.
이벤트 소싱을 사용하면, 해당 시점의 이벤트를 수정하는 '정정 이벤트'를 추가한 뒤, 시스템이 두 애플리케이션 상태의 차이를 계산(diff)하여 필요한 모든 조정을 자동으로 계산하도록 할 수 있습니다.
이는 수동으로 처리하기에는 악몽과도 같은 작업입니다.
```

솔직히 이 부분은 완전히 와닿지는 않았음. (결국 정정 이벤트를 처리하는 비즈니스 로직을 구현해야 되는거 아닌가..?)

- **고성능 인메모리 시스템 구현 (Memory Image)**: 이벤트 로그가 영구 저장소의 역할을 하므로, 애플리케이션의 전체 상태를 데이터베이스 없이 메모리에 두고 운영할 수 있음

계산에 필요한 모든 데이터가 이벤트에 있고, 계산 결과의 영속성이 필요 없으면 가능할 것 같음.

예를 들어, 은행 시스템의 계좌 총합의 경우 거래 내역이 모두 저장되어 있고(소싱된 이벤트), 이를 통해 계산된 총합을 영속화할 필요는 없으니 이에 해당되는 케이스가 아닐까 싶음.

### 단점

- **생소함과 복잡성**
- **이벤트 스키마 버전 관리**

```
시간이 흐름에 따라 이벤트의 구조(스키마)가 변경될 수 있습니다.
1년 전에 기록된 구버전의 이벤트를 현재의 새로운 코드가 어떻게 처리해야 할지에 대한 버전 관리 전략은 매우 복잡하고 어려운 문제입니다.
```

## CQRS

> 시스템의 상태를 변경하는 '커맨드 모델(Command Model)'과 상태를 조회하는 '쿼리 모델(Query Model)'을 소프트웨어적으로 완전히 분리하는 것

"업데이트에 사용되는 커맨드 모델은 외부의 조회 목적으로는 절대 사용되지 않는다" 는 점이 중요.

### 장점

- **조회 성능**: 조회는 매우 빈번하고 빨라야 하는 특정 시나리오에서 큰 가치를 발휘

### 단점

- **코드 복잡성 증가**: 두 개의 모델을 유지해야 하는 데서 오는 복잡도
- **모델간 동기화 문제**

이 부분은 상대적으로 얕은 언급이었던 것 같다. (추후 별도로 공부 필요할듯)

## 출처

- https://youtu.be/STKCRSUsyP0?si=1ndx9kiW9VG-cmAJ