# Transactional Outbox/Inbox Pattern

## 배경

트랜잭셔널 아웃박스/인박스 패턴은 아래와 같은 환경에서 기인한다.

#### 1. 분산 시스템

DB, 애플리케이션 서버, 메시지 브로커가 네트워크로 연결되어 있는 분산 환경.
네트워크 실패, 프로세스 다운, 메시지 중복/유실/지연 등이 발생할 수 있다.

#### 2. 상태 변경 + 이벤트 발행이 비즈니스적으로 중요한 환경

- 상태 변경이 외부 시스템에 반드시 전파되어야 함
- 이벤트 유실이 비즈니스 장애로 직결

SAGA 분산 트랜잭션을 구현할 때 보상 트랜잭션을 위한 이벤트 발행이 해당된다.

### 이러한 환경에서 발생하는 문제들

#### 1. DB는 커밋됐는데 메시지는 못 보냄

```
TX BEGIN
INSERT order
TX COMMIT
publish OrderCreatedEvent --> 실패 (네트워크 장애)
```

- 주문은 저장되었으나, 다른 서비스는 전파받지 못함

#### 2. 메시지는 발행됐는데 DB는 롤백됨

```
TX BEGIN
INSERT order
publish OrderCreatedEvent
TX ROLLBACK
```

- 주문 생성됨을 다른 서비스들이 전파 받으나, 실제 주문 데이터는 없음

#### 3. 메시지 중복 및 순서 뒤틀림

- 네트워크 재시도, 브로커 재전송, consumer 재처리 등의 이유로 동일한 메시지가 중복될 수 있음
- 그 과정에서 메시지간 순서가 뒤틀릴 수도 있음 (e.g. A, B 순서대로 발행되었지만 A실패 -> B성공 -> A재시도 케이스에서는 B, A 순서대로 처리됨)

## Outbox/Inbox 컨셉

Outbox와 Inbox는 사무실에서 전통적인 종이 기반 업무에서 활용된 분류 방법이라고 한다.
이는 문서를 보관하는 공간으로 Inbox는 처리해야할 문서, Outbox는 처리해서 보내야할 문서를 넣었다고 한다.
사원은 Inbox의 문서를 읽어 업무를 처리하고, 추가로 외부로 나가야 하는 문서를 Outbox에 넣는 식으로 업무를 처리했고,
비서가 주기적으로 새로 들어온 문서를 Inbox에 추가하고, Outbox에 있는 문서를 가져가 외부로 전달했다고 한다.

이메일 시스템은 이 컨셉을 차용하여 동일한 명칭의 기능을 도입한다.
이메일에서 Inbox는 '받은메일함'으로, 외부에서 수신된 메일들을 보관하는 곳이다.
다음메일, 지메일 등의 서비스에서 받은메일함을 가면 주소창에 'Inbox'로 표기되어 있음을 확인할 수 있다.
이메일에서 Outbox는 '보낼메일함'으로, 인터넷 연결이 불안정하거나 서버 문제로 바로 발송되지 못한 이메일이 임시로 보관되는 곳이다.
웹 기반 메일 서비스는 항상 인터넷에 연결되어 있음을 가정하기 때문에 없는 경우가 있는데, 모바일 또는 PC 메일 클라이언트는 아직 존재하는 것 같다.

이처럼 Inbox와 Outbox는 수신받거나 발신해야 하는 메시지를 임시로 보관하는 장소의 역할을 한다.
Inbox의 문서를 처리하다가 급한일이 생겨 다시 Inbox에 넣으면 까먹지 않고 다시 해당 문서를 처리할 수 있다. (재처리)
처리가 완료된 문서를 무조건 Outbox에 넣는다면, 문서를 까먹고 외부에 전달하지 않는 불상사를 막을 수 있다. (전달중에 누락이 되어도 최소한 내 책임이 아니게 된다)
트랜잭셔널 아웃박스/인박스 패턴은 개념적으로 이와 동일한 방식으로 구현된 패턴이다.

## Transactional Outbox Pattern

<img width="1298" height="461" alt="image" src="https://github.com/user-attachments/assets/90461307-817e-4567-b9c0-77cae380a777" />

### 핵심 로직 처리 순서

1. 서비스는 트랜잭션을 걸고, 그 안에서 비즈니스 로직을 수행하여 데이터를 수정한다. (e.g. 주문 추가를 위해 order 테이블에 row 추가)
2. 동일한 트랜잭션 내에서 outbox 테이블에 발행이 필요한 메시지를 기록한다. (e.g. OrderCreatedEvent를 outbox 테이블에 추가)
3. 별도의 스레드/프로세스(Message Relay)가 주기적으로 outbox 테이블을 읽고 아직 발행이 안된 메시지를 발행한다.
4. 발행에 성공한 메시지는 상태를 완료로 업데이트 한다. (주기적으로 재발송되지 않도록)

### 특징

#### at-least-once 보장으로 인한 중복 발행

- 메시지 발행 후 outbox 테이블을 업데이트하는 과정에서 실패하는 케이스 때문에 메시지 중복 발행 가능성이 존재
- 따라서, 메시지 수신측에서 중복으로 처리되도 문제 없도록 설계하거나 실제 처리는 한번만 되도록 '멱등성'을 구현해야 함 (이를 위한 설계가 뒤에 나올 트랜잭셔널 인박스 패턴임)

#### outbox 테이블 누적

- 발행되는 모든 메시지를 기록하기 때문에 빠르게 테이블 용량이 증가할 수 있음
- 이로 인해 주기적인 발행을 위해 테이블을 조회하는 쿼리의 지연이 증가할 수 있음 (따라서 발행전 메시지를 조회하기 위한 인덱스는 필수)
- 따라서, 보관 기간 정책을 세우고 파티셔닝/아카이빙 등을 통해 일정 크기를 넘지 않도록 outbox 테이블 관리가 필요

#### 폴링 간격/지연 vs 부하 트레이드오프

- Message Relay의 폴링 간격을 줄이면 지연이 줄어드나 DB 부하가 증가하고, 폴링 간격을 늘리면 지연이 늘어남
- 따라서, 비즈니스와 인프라 환경에 적합한 폴링 간격 설정 필요
- 대부분의 케이스에서 지연을 최소화하기 위해 Message Relay에서의 발행 외에도 애플리케이션이 트랜잭션 커밋 직후 직접 메시지를 발행하도록 구현하기도 함 (스프링에서는 `@TransactionalEventListener` 사용)

### 비고

#### Transaction Log Tailing Pattern

위에서 설명한 패턴은 폴링 발행기 패턴(Polling Publisher Pattern)이다.
폴링의 부하가 부담되는 규모의 서비스는 트랜잭션 로그 테일링 패턴(Transaction Log Tailing Pattern)을 사용한다.

트랜잭션 로그 테일링 패턴은 DB의 트랜잭션 로그(커밋 로그)를 직접 읽어 메시지를 발행하는 방식이다.

이외에도 아래와 같은 케이스에서 트랜잭션 로그 테일링 패턴을 사용한다.

- 애플리케이션 코드 변경이 불가능한 경우 (레거시, 외부 서비스 등)
- 모든 변경이 이벤트가 되어야 하는 경우 (polling outbox는 개발자가 의도적으로 구현한 이벤트만 발행됨)

하지만 단점도 여럿 있다.

- 운영 난이도 높음
- 데이터베이스에 종속적인 구현이 필요 (MySQL은 binlog, Oracle은 redo log 등 트랜잭션 로그 스펙이 DB별로 다름)
- 중복 발행을 피하기 어려움 (polling outbox와 다르게 발행 상태를 따로 관리하지 않기 때문)

## Transactional Inbox Pattern

(TODO)

## 참고

- ChatGPT
- https://microservices.io/patterns/data/transactional-outbox.html
- https://microservices.io/patterns/data/transaction-log-tailing.html
- https://inma.tistory.com/199
- https://curiousjinan.tistory.com/entry/kafka-consumer-inbox-pattern
