# 'MySQL을 이용한 분산락으로 여러 서버에 걸친 동시성 관리' 아티클 정리

## 분산락을 적용한 이유

- MySQL DB에 user, card 테이블이 있고 user와 card는 1:N 관계
- user는 card를 2개 이상 추가할 수 없는 제약이 있음 (제약은 엔티티 모델 코드로 존재)

### 카드 추가 서비스 로직

```
1. user 조회 (one to many 관계로 연관된 card 목록도 함께 조회됨)
2. user.addCard() 호출 (이미 card가 2개인 경우 예외 던짐)
```

### 동시성 문제

특정 유저의 카드 추가하는 요청을 동시에 여러번 호출시 동시성 문제로 카드가 여러개(2개 이상) 생성되어 있다.

해당 문제를 해결하기 위해 분산락을 도입함.

## MySQL로 분산락을 구현한 이유

- 락 사용량이 낮아 추가 인프라 도입은 불필요하다 판단 (이미 MySQL을 메인 DB로 사용중)
- MySQL의 USER-LEVEL LOCK(네임드락) 기능이 필요한 요구사항에 충분하다 판단

### 분산락 구현

- 락을 얻는 부분이 로직을 수행하는 부분에 영향을 주는것을 방지하기 위해 각각에 대한 커넥션풀을 분리함
- `GET_LOCK()`과 `RELEASE_LOCK()`을 이용해 executeWithLock() 래퍼를 만들고, 비즈니스 로직을 Supplier<T> 콜백으로 실행하게 구현
- 처음에는 NamedParameterJdbcTemplate으로 시도했으나, 쿼리 실행 후 바로 커넥션을 반납하는 동작 때문에 락을 얻은 커넥션/반납할 커넥션이 달라지는 문제 발견 -> LOCK 반환 실패 가능
- 락 획득/반납 전체 주기를 트랜잭션으로 묶어 해결 시도도 했으나, 이 경우에는 락 로직과 실제 처리 로직이 동일한 커넥션을 사용하게 되는 문제가 남음
- 최종적으로 DataSource에서 직접 JDBC Connection을 꺼내 `GET_LOCK()`와 `RELEASE_LOCK()`을 같은 커넥션으로 실행하도록 구현

## 참고

- https://techblog.woowahan.com/2631/

# 내용 추가 (TODO)

## 꼭 분산락으로 해결해야 됐던 문제인가?

## 락과 로직간의 커넥션풀을 분리함으로써 얻는 실질적인 이득은 무엇인가?

## RELEASE_LOCK 호출 유실로 락이 반납이 안되는 케이스는 어떻게 해결해야 할까?
