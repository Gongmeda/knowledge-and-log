# '트랜잭션은 도메인 모델이 아니다' 아티클 정리

> 도메인 주도 설계(DDD)의 핵심 원칙인 '순수한 도메인 모델'을 유지하면서, 실세계에서 반드시 마주치는 '데이터 동시성' 문제를 어떻게 우아하게 해결할 수 있는가?

작성자는 위 의문을 해결한 방법에 대해 설명한다.

## 배경

실시간으로 서로 다른 두 프로세스가 같은 데이터를 '읽고 -> 변경하고 -> 저장' 할 때, 동시에 실행되면 나중 저장이 이전 변경을 덮어써서(Write Skew/갱신 유실) 심각한 오류가 날 수 있다.

이 문제를 막기 위해 트랜잭션 + 비관적 락을 고민하게 되지만, 트랜잭션 같은 것은 도메인 지식이 아니라 '영속성 지식' 이기 때문에 이를 도메인 모델에 노출시키면 모델이 오염된다고 본다.

또 다른 동시성 문제 해결 방법으로 낙관적 락을 고려한다.

이를 사용하려면 보통 버전 값을 읽고 들고 있다가 update 시점에 비교해야 해서, 결국 명령/이벤트 처리 코드(도메인 서비스)가 버전 정보에 의존하게 되고 도메인 모델에도 버전 필드가 들어가기 쉬운데, 저자는 이 접근을 피한다. 

반대로 버전, 락, 트랜잭션을 숨기려고 리포지토리에 `switchOn`, `handle` 같은 메서드를 늘려서 그 안에서 트랜잭션 처리를 해버리면, 이번엔 핵심 비즈니스 로직이 리포지토리 구현체로 흘러 들어가 재사용성과 구조가 나빠진다고 본다. 

결론적으로 '명령/이벤트 처리기가 엔티티를 직접 읽어와 수정 후 저장'하는 흐름을 유지한 채로는 영속성 지식이 도메인으로 주입 되거나, 비즈니스 로직이 도메인 밖으로 새는 딜레마가 생긴다.

## 해결 방법

> 코드 흐름 제어권 배치를 바꾼다. (IoC) 

리포지토리가 `update(id, modifier)`처럼 '식별자 + 수정 함수(람다)'를 받아 트랜잭션 안에서 'load -> (락/버전 체크 포함 가능) -> modifier 적용 -> save'까지 책임진다.

```java
public final class BudgetExhaustedEventHandler {

    private final ICampaignRepository repository;

    public BudgetExhaustedEventHandler(ICampaignRepository repository) {
        this.repository = repository;
    }

    public void handle(BudgetExhausted event) {
        repository.update(event.getId(), campaign -> campaign.handle(event);
    }
}
```
```java
public class CampaignRepository implements ICampaignRepository {

    private final CampaignJpaRepository jpaRepository;
    private final EventStore eventStore;

    ...

    @Transactional
    @Override
    public void update(UUID id, Consumer<Campaign> modifier) {
        CampaignDataModel dataModel = jpaRepository.findById(id)
            .orElseThrow(AggregateNotFoundException::new);
        Campaign campaign = dataModel.toEntity();
        modifier.accept(campaign);
        dataModel.update(campaign);
        eventStore.store(campaign.getEvents());
    }
}
```

이렇게 하면 트랜잭션, 락, 버전 등의 정보는 도메인 외부로 격리되고, 비즈니스 로직만 도메인에 유지해서 오염과 로직 확산을 동시에 피할 수 있다.

## 출처

- https://blog.gangnamunni.com/post/isolate-transaction-from-domain-model

# 내용 추가

'이렇게 구현할 수도 있구나' 싶었다.

처음에는 이게 왜 IoC지?라는 의문이 있었는데 '누가 흐름을 주도(시퀀싱)하고, 누가 누구를 호출하는가'가 제어권이라는 관점에서 흐름을 레포지토리가 처리하고 그 과정에서 서비스로부터 전달받은 콜백을 호출하므로 IoC임을 이해했다.

다만, 트랜잭션이 레포지토리 구현체에 존재해야 하는 이유는 잘 이해가 안됐다.

일반적인 DDD 기반의 레이어 구조라면 애플리케이션 서비스 레이어가 존재할텐데, 여기에 트랜잭션 정보가 있으면 되는거 아닌가? 싶었다.

추가로, 트랜잭션을 건다는 정보가 암묵적으로 숨겨지는게 좋은 방향인지도 조금 의문이었다.

`@Transactional` 어노테이션을 붙이는게 'MySQL의 트랜잭션을 건다'와 같이 영속성 레이어 specific한 동작을 의미할 수도 있겠지만, 해당 비즈니스 로직이 원자적으로 동작함을 지칭하는게 더 크다고 생각한다.

단지 해당 어노테이션을 JPA라는 영속성 구현체가 AOP로 읽어서 암묵적으로 해당 처리를 해줄 뿐인거다.

만약 DB를 MongoDB로 변경하고 해당 DB에선 트랜잭션을 사용하지 못한다고 하면, `@Transactional` 을 도메인 외부로 옮겼다고 해서 해당 로직이 안깨질까?

어차피 DB를 바꾸더라도 원자적 연산을 보장해야 함은 동일하다.

그리고 '무조건 애그리거트 단위의 수정만 존재한다'가 보장된다면 해당 패턴에서 벗어나는 케이스가 없겠지만, 만약 UseCase 단위의 트랜잭션이 필요하다거나 트랜잭션 아웃박스 패턴과 같이 동일 트랜잭션 안에서 수행해야 하는 어떤 다른 작업이 존재하면 깨지게 되는 패턴이 아닌가 싶다.
