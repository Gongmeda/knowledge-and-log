# 도메인 모델 패턴

## 도메인 모델 패턴이란?

'도메인 모델'은 애플리케이션의 핵심 비즈니스 규칙과 개념을 표현한 객체 모델이다.
비즈니스 용어, 규칙, 제약을 코드의 중심에 두고, 이를 책임과 협력으로 모델링한다.

핵심은 '데이터 구조 + 행동(비즈니스 로직)'을 하나의 모델로 묶는 것.

도메인 모델을 흔히 2가지 종류로 나누기도 한다.
1. rich 도메인 모델 (풍부한 도메인 모델)
2. anemic 도메인 모델 (빈약한 도메인 모델)

rich 도메인 모델은 도메인 객체가 상태 + 행동(비즈니스 로직)을 모두 가진 모델.

anemic 도메인 모델은 도메인 객체에 데이터만 존재하고, 비즈니스 로직은 대부분 모델 외부(보통 서비스)에 위치하는 모델.

따라서, 일반적으로 "도메인 모델 패턴을 사용했다" 라고 하면 rich 도메인 모델을 구현했다는 의미로 해석되는 것 같다.

## rich 도메인 모델과 객체지향

객체지향적 설계를 위해서는 아래의 원칙이 지켜져야 함.
- 객체가 자기 상태를 스스로 관리한다 (encapsulation)
- 행동(메서드)이 상태를 지켜주는 규칙을 포함한다 (invariants 보호)

rich 도메인 모델은 이러한 객체지향의 원칙을 충실하게 적용한 형태라 볼 수 있다.

- 데이터와 행동의 응집
- 불변성(Value Object)
- 캡슐화
- 메시지(메서드)를 통한 협력

이 때문에 anemic 도메인 모델은 "데이터와 프로세스를 함께 결합하려는 객체지향 설계의 기본 사상에 정면으로 위배된다"라는 이유로 안티 패턴 취급을 받기도 한다. (by. 마틴 파울러)

## rich 도메인 모델 도입시 고려사항

### rich 도메인 모델의 장단점

| 구분     | 내용                                           |
| -------- | ---------------------------------------------- |
| **장점** | 비즈니스 로직이 도메인 객체에 캡슐화되어 변경·확장이 용이 |
|          | 비즈니스 로직이 캡슐화 되어 있어 재사용성 증가 |
|          | 객체 상태에 대한 불변식(invariants)이 자연스럽게 보호됨 |
| **단점** | 단순한 시스템에서는 과도한 설계가 될 수 있음   |
|          | ORM 매핑 복잡도 증가                           |
|          | 도메인 이해와 객체지향/DDD 개념에 대한 학습 부담 존재 |
|          | 잘못 설계하면 '무거운 모델 + 낮은 생산성'을 초래 |


### 언제 rich 도메인 모델을 사용하는게 좋을까?

- 복잡한 비즈니스 로직이 내장된 시스템 (e.g. 금융, 커머스 ...)
- 도메인 규칙과 정책의 강제가 중요할 때
- 장기적으로 유지보수와 확장이 매우 중요한 프로젝트

> 비즈니스 로직이 복잡해서 적용해야 하는 규칙과 보호해야하는 불변식이 많고, 이를 오랜 기간동안 유지보수 해야하는 경우 유리

## rich 도메인 모델과 DDD 전술적 설계(Tactical Design)

rich 도메인 모델은 DDD의 핵심이며, DDD의 전술적 설계 구성요소들을 통해 구체화됨.

전술적 설계는 다음 요소들로 구성된다.
- Entity, Value Object
- Aggregate & Aggregate Root
- Domain Event
- Repository
- Domain Service

## rich 도메인 모델과 클린/헥사고날 아키텍처

**둘은 직접적인 연관관계는 없다.**

- rich 도메인 모델 -> '도메인 로직을 어디에 두는가?'에 대한 전술적 설계 방식 = **도메인 계층 내부의 설계 방식**
- 클린/헥사고날 아키텍처 -> '계층 간 의존 방향을 어떻게 유지할 것인가?'에 대한 아키텍처 스타일 = **전체 아키텍처의 관심사 분리 규칙**

| 개념            | 해결하려는 문제                     |
| ------------- | ---------------------------- |
| **클린 아키텍처**   | 의존성 분리, 기술/인프라 독립성           |
| **anemic vs rich** | 도메인 로직을 어디에 둘 것인가(서비스 vs 객체) |

anemic 모델과 클린 아키텍처의 조합으로 구현할 수도 있음.

anemic 도메인 모델 기반이라도 클린 아키텍처를 도입하면 어플리케이션 레이어(Use Case)에 비즈니스 로직이 있고, 이 레이어가 인프라에 의존하지 않고 모든 외부 요소(DB, 메시지 브로커, 외부 API)와는 인터페이스로 분리됨.

-> 비즈니스 로직이 외부 기술 변화로부터 보호되는 클린 아키텍처의 장점은 그대로 유지된다.

### 왜 둘은 함께 언급되는 경우가 많을까?

많은 경우 둘이 함께 언급되거나 같이 적용되는 이유는 다음과 같다고 생각한다.

클린 아키텍처를 도입하는 기본적인 이유는 비즈니스 로직을 다루는 코드에서 외부 의존성을 배제하여 핵심 로직이 기술 변화에 흔들리지 않도록 하는 것, 즉 **비즈니스 로직의 유지보수성을 높이기 위함**이다.
의존 방향을 관리한다는 것은 외부 변화로부터 핵심 로직을 보호하는 것이고, 이는 결과적으로 **변화 영향도를 격리하여 중요한 영역의 코드를 유지보수하기 좋은 구조로 만들기 위함**이다.

따라서, 클린 아키텍처로 외부 변화에 강한 핵심 레이어를 구축해 뒀는데, 그 핵심 레이어의 코드가 내부적으로 응집되지 않고 유지보수하기 어려운 구조(anemic 도메인 모델)로 흩어져 있다면 목적과 맞지 않는 지점이 발생한다.

결과적으로 ‘비즈니스 로직을 표현하는 코드의 유지보수성을 극대화한다’라는 관점에서 보면, 클린 아키텍처와 rich 도메인 모델은 방향성이 맞닿아 있는 구조이고, 그래서 함께 쓰이는 경우가 많다고 생각한다.

- anemic 도메인 모델 + 클린 아키텍처 -> **기술적 독립성 O, 도메인 응집성 X**
- rich 도메인 모델 + 클린 아키텍처 -> **기술적 독립성 O, 도메인 응집성 O**

> 둘의 효과가 시너지를 만들며 도메인 설계 품질이 올라감

## 참고

- https://en.wikipedia.org/wiki/Domain_model
- https://en.wikipedia.org/wiki/Anemic_domain_model
- https://martinfowler.com/eaaCatalog/domainModel.html
- https://java-design-patterns.com/patterns/domain-model/#programmatic-example-of-domain-model-pattern-in-java
