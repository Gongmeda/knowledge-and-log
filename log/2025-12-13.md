# 'MySQL을 이용한 분산락으로 여러 서버에 걸친 동시성 관리' 아티클 정리

## 분산락을 적용한 이유

- MySQL DB에 user, card 테이블이 있고 user와 card는 1:N 관계
- user는 card를 2개 이상 추가할 수 없는 제약이 있음 (제약은 엔티티 모델 코드로 존재)

### 카드 추가 서비스 로직

```
1. user 조회 (one to many 관계로 연관된 card 목록도 함께 조회됨)
2. user.addCard() 호출 (이미 card가 2개인 경우 예외 던짐)
```

### 동시성 문제

특정 유저의 카드 추가하는 요청을 동시에 여러번 호출시 동시성 문제로 카드가 여러개(2개 이상) 생성되어 있다.

해당 문제를 해결하기 위해 분산락을 도입함.

## MySQL로 분산락을 구현한 이유

- 락 사용량이 낮아 추가 인프라 도입은 불필요하다 판단 (이미 MySQL을 메인 DB로 사용중)
- MySQL의 USER-LEVEL LOCK(네임드락) 기능이 필요한 요구사항에 충분하다 판단

### 분산락 구현

- 락을 얻는 부분이 로직을 수행하는 부분에 영향을 주는것을 방지하기 위해 각각에 대한 커넥션풀을 분리함
- `GET_LOCK()`과 `RELEASE_LOCK()`을 이용해 executeWithLock() 래퍼를 만들고, 비즈니스 로직을 Supplier<T> 콜백으로 실행하게 구현
- 처음에는 NamedParameterJdbcTemplate으로 시도했으나, 쿼리 실행 후 바로 커넥션을 반납하는 동작 때문에 락을 얻은 커넥션/반납할 커넥션이 달라지는 문제 발견 -> LOCK 반환 실패 가능
- 락 획득/반납 전체 주기를 트랜잭션으로 묶어 해결 시도도 했으나, 이 경우에는 락 로직과 실제 처리 로직이 동일한 커넥션을 사용하게 되는 문제가 남음
- 최종적으로 DataSource에서 직접 JDBC Connection을 꺼내 `GET_LOCK()`와 `RELEASE_LOCK()`을 같은 커넥션으로 실행하도록 구현

## 출처

- https://techblog.woowahan.com/2631/

# 내용 추가

## 꼭 분산락으로 해결해야 됐던 문제인가?

글의 배경이 되는 실제 환경은 예시의 구조보다 훨씬 복잡할 것이다.

예상하기로는 여러 서버에 걸친 강한 일관성이 필요하고, 쓰기 작업이 여러 서비스에 걸쳐있는 형태가 아닐까 생각한다.

그래서 실제 환경에서는 분산락이 필요한 타당한 이유가 있었겠지만, 예제의 상황만 보면 좀 다르다.

이를 기준으로 생각해보면 꼭 분산락이 아니더라도 해결할 수 있는 방법은 존재한다.

일단 예제는 단일 DB 환경이고, 이 경우라면 DB락 만으로도 해결이 가능했을 것으로 보인다.

1. **user 엔티티 row lock**: `SELECT user ... FOR UPDATE` 와 같은 쿼리로 수정하는 user 엔티티의 row를 lock하고 조회 + 수정 (대신 이 방법은 user의 데이터를 수정하는 로직과 충돌되어 무관한 요청도 블락할 수 있음)
2. **별도의 앵커 테이블 사용**: `card_quota` 같은 테이블을 별도로 만들어 사용. 다른 요청과 락을 격리할 수는 있지만 스키마 변경이 필요. 사실상 테이블 기반 네임드락 (대신 네임드락의 단점은 상쇄됨)

### 그럼에도 네임드락이 더 나은 점?

1. **락 범위를 '특정 행위'로 정확히 격리할 수 있다**: row lock은 앵커를 잘못 잡으면 쉽게 과잠금(over-locking)이 됨. 따라서 card 추가를 위해 user의 컬럼 수정을 블락하는 등의 현상을 회피할 수 있음 (잘 설계된 격리는 필수)
2. **기존 데이터 접근 패턴을 건드리지 않아도 된다**: 스키마 변경, 쿼리 변경, 인덱스 등을 고려하지 않으면서 동시성 문제를 해결할 수 있음
3. **분산 환경으로의 이행 비용이 낮다**: 서비스가 분산 환경으로 이전되면 락 키와 사용 패턴은 그대로 구현체만 교체하여 대응할 수 있음

다만 단점도 존재한다.

네임드락 뿐만 아니라 분산락은 근본적으로 모든 변경 경로가 자발적으로 참여하지 않으면 불변식을 강제할 수 없다는 점에서 설계적으로 취약하다.

## 락과 로직간의 커넥션풀을 분리함으로써 얻는 실질적인 이득은 무엇인가?

락과 로직이 동일한 커넥션을 사용해도 사실 문제가 될 부분은 없어보일 수 있다.

오히려 분리시 동시에 2개의 커넥션을 사용해야 하는게 자원 낭비처럼 보일 수도 있다.

정상 케이스에서는 맞는 말이지만 동일한 커넥션 풀을 사용하는게 문제가 될 수 있는 시나리오가 있다.

대부분의 락은 대기 시간이란게 존재하고, 그 동안 커넥션을 점유하는 구조이다.

게다가 네임드락은 해제 TTL이 없어 수동으로 해제 처리해주지 않으면 복구가 안되는 문제가 있다. (심지어 동일 커넥션에서만 해제 가능)

따라서, 만약 로직 처리의 커넥션풀을 공유해서 사용하게 되면 락 해제 누락으로 이후 요청들이 락 대기로 인해 커넥션풀을 점유하게 되는 시나리오가 가능한 것이다.

```
1. A, B, C 요청이 존재. A는 락을 사용하고 B, C는 단순 조회 & 락 없이 DB 수정하는 로직이라 가정
2. A 요청 처리 후 락을 해제하는 쿼리가 일시적인 문제로 누락 -> 해제 안됨
3. 이후 N번의 A 요청을 통해 N개의 커넥션풀이 점유됨
4. 모든 커넥션풀이 락 획득을 위한 대기로 점유 상태가 되고, 락과 연관이 없는 B, C 요청까지 처리 불가능 상태가 됨
```

작성자는 이러한 이슈를 방지하기 위해 커넥션풀을 분리한 것으로 예상된다.

사실 이런 문제는 TTL이 있는 락을 사용해도 일정 시간동안은 발생할 수 있는 문제라고 볼 수 있다. (락 TTL 시간동안은 동일 현상 발생)

추가 방지책으로는 아래 처리들이 가능할 것이다.

1. **락 대기 시간 0 or 최소화**: 락 대기로 커넥션이 묶이는 시간을 줄여 풀 고갈 전이를 방지 (대신 빠른 실패/재시도 설계 필요)
2. **해제 실패 시 커넥션 폐기**: 락 해제가 실패한 경우, 세션 종료를 통해 락을 즉시 해제하여 락 누수 최소화
3. **세션 생존 시간 제한 + 실패 시 커넥션 폐기**: 알 수 없는 이유로 해제 누락 시에도 세션 종료를 통해 락이 장기간 잔류하지 않도록 자가 복구 경로 마련 (HikariCP `max-lifetime`, MySQL `wait_timeout` 옵션)
